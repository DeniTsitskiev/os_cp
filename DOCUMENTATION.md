# Документация: как работает проект "Быки и Коровы"

Этот файл подробно описывает архитектуру проекта, используемые компоненты, сетевой протокол сообщений (ZeroMQ), основные системные вызовы и поведение при многопоточности.

## Краткий обзор

- Проект состоит из двух программ: `server` и `client`.
- Сервер хранит состояние множества игр; каждая игра имеет имя, загаданное слово и набор игроков.
- Клиенты подключаются к серверу по TCP через библиотеку ZeroMQ, используют паттерн `REQ`/`REP` (запрос/ответ).
- Сообщения текстовые, человекочитаемые; команды: `LIST`, `CREATE <game> <max> <player>`, `JOIN <game> <player>`, `GUESS <id> <player> <word>`, `LEAVE <id> <player>`.

## Архитектура и ключевые модули

- `server.c`:
  - Управляет массивом структур `Game` размера `MAX_GAMES`.
  - Для каждой игры хранит `game_name`, `secret_word` (внутренне — wide string `wchar_t` для корректной поддержки кириллицы), `max_players`, `current_players`, массив `Player`.
  - Мьютекс `games_lock` защищает глобальные операции с массивом игр; каждый `Game` содержит `pthread_mutex_t lock` для локальной синхронизации состояния одной игры.
  - Сервер использует ZeroMQ сокет типа `ZMQ_REP` и ожидает входящих `ZMQ_REQ` сообщений от клиентов.

- `client.c`:
  - Интерактивная консольная программа: меню, ввод пользователя, отправка команд серверу и отображение ответов.
  - Использует `ZMQ_REQ` и ожидает `ZMQ_REP` ответа для каждого запроса.

## Протокол обмена сообщениями (формат)

- Запросы (клиент → сервер):
  - `LIST` — запрос списка активных игр.
  - `CREATE <game_name> <max_players> <player_name>` — создать игру.
  - `JOIN <game_name> <player_name>` — присоединиться к игре.
  - `GUESS <game_id> <player_name> <word>` — попытка угадать слово.
  - `LEAVE <game_id> <player_name>` — выйти из игры.

- Ответы (сервер → клиент):
  - `OK:<текст>` — успешная операция.
  - `ERROR:<текст>` — ошибка.
  - `RESULT:Быки: X, Коровы: Y (попытка N)` — результат попытки.
  - `WIN:<текст>` — сообщение о победе.

Замечание: текущий проект использует текстовый протокол, прост в отладке, но парсинг строк хрупкий; рекомендовано использовать структурированные форматы (JSON) для стабильности.

## ZeroMQ и паттерн `REQ`/`REP`

- ZeroMQ предоставляет лёгкую оболочку поверх системных сетевых сокетов и реализации транспорта (TCP, IPC и т.д.).
- В проекте сервер создаёт контекст `zmq_ctx_new()` и сокет `zmq_socket(context, ZMQ_REP)`, затем `zmq_bind(responder, "tcp://*:5555")`.
- Клиент использует `zmq_socket(context, ZMQ_REQ)` и `zmq_connect(requester, "tcp://localhost:5555")`.
- Поведение `REQ`/`REP`: строгая синхронизация запрос-ответ — клиент посылает запрос и ждет ответа; сервер читает запрос, формирует ответ и посылает его.
  - Недостаток: `REP` сокет блокирует обработку следующего запроса, пока не отправит ответ; это упрощает логику, но снижает гибкость при сложной асинхронной обработке.
  - Для масштабирования можно использовать `ROUTER/DEALER` или многопоточную обработку сообщений.

## Основные системные вызовы и библиотечные вызовы

Приведённый список — ожидаемые системные вызовы, которые выполняются при запуске и работе программ (часть из них вызывается явно стандартной библиотекой или ZeroMQ):

- Управление процессами и потоки:
  - `fork()` — не используется напрямую в проекте; сервер использует `pthread_*` для потоков и мьютексов.
  - `pthread_create`, `pthread_mutex_lock`, `pthread_mutex_unlock` — POSIX API (вызовы библиотеки `libpthread`). В ядре они реализованы через `clone`/`futex`.

- Сеть и сокеты (через ZeroMQ):
  - `socket(2)`, `bind(2)`, `listen(2)`, `accept(2)` — создаются внутри реализации ZeroMQ при использовании `tcp://*` и слушающих сокетов.
  - `connect(2)` — вызывается внутри ZeroMQ у клиента.
  - `sendmsg(2)` / `recvmsg(2)` (или `sendto`/`recvfrom`) — отправка/получение сетевых данных.
  - `setsockopt(2)` — установка опций сокета (таймауты, буферы и т.д.).
  - `poll(2)` / `epoll_wait(2)` — ожидание событий ввода/вывода внутри ZeroMQ.

- Работа с памятью и аллокация:
  - `brk(2)` / `sbrk(2)` и `mmap(2)` — выделение динамической памяти через malloc/free (реализация libc использует эти вызовы).

- Файловые операции (если логировать в файл):
  - `open(2)`, `write(2)`, `close(2)` — при записи логов; в тестовом запуске сервер может писать stdout/stderr, перенаправляемые оболочкой в файлы.

- Прочие вызовы:
  - `time(2)` — вызов `time(NULL)` для инициализации `srand()`.
  - `getenv` / `setlocale` (C library) — работа с локалью; `setlocale` использует системные механизмы локали.

Замечание: ZeroMQ скрывает большую часть низкоуровневых системных вызовов, но фактически использует OS-сокеты и мультиплексоры (epoll/kqueue/poll).

## Синхронизация и многопоточность

- Глобальный мьютекс `games_lock` защищает создание/перечисление игр и изменение `games_count`.
- Каждый `Game` имеет свой `pthread_mutex_t lock` — обеспечивает консистентность при обновлении игроков, попыток, флагов `active` и `winner_found`.
- Паттерн: блокировка верхнего уровня (`games_lock`) на период поиска нужной игры, затем локальная блокировка `game->lock` для изменений конкретной игры.

Проблемы и нюансы:
- При удалении/закрытии игр важно корректно обрабатывать `current_players` и реиспользование слотов; в проекте реализована простая стратегия — поиск неактивных слотов.
- Следует избегать удержания глобального мьютекса на длительное время — лучше минимизировать критические секции.

## Работа с кириллицей (UTF-8)

- В исходнике сервер хранит `secret_word` в `wchar_t`, словарь задан как `wchar_t*` (L"..."). Для приёма слова от клиента выполняется `mbstowcs` (многобайтовая → wide) с помощью текущей локали (`setlocale(LC_CTYPE, "")`).
- Клиент отправляет UTF-8, поэтому важно, чтобы среда выполнения (терминал, переменная `LANG`) была настроена на UTF-8 (например, `ru_RU.UTF-8`).

Ограничения:
- Использование `mbstowcs` / `wcstombs` зависит от текущей C‑локали; в многопользовательской среде лучше применять библиотеки, корректно работающие с UTF-8 (например, ICU или явные UTF-8 парсеры), либо работать исключительно в `char` с явной обработкой UTF-8.

## Поведенческие сценарии (примерные последовательности)

1. Клиент A: `CREATE game1 3 Alice` → сервер создаёт игру, загадывает слово (внутренне wide), добавляет игрока Alice.
2. Клиент B: `JOIN game1 Bob` → сервер добавляет Bob (реиспользуя неактивные слоты при наличии).
3. Клиент A: `GUESS 0 Alice слово` → сервер конвертирует `слово` в `wchar_t`, считает быков и коров и возвращает `RESULT` либо `WIN`.
4. Клиент B: `LEAVE 0 Bob` → сервер помечает Bob как неактивного; игра продолжается для активных игроков.

## Ошибки и обработка исключений

- Сервер возвращает `ERROR:` с текстом в случаях: неверный формат команды, игра не найдена, игра заполнена, игрок не найден, длина слова не совпадает и т.д.
- ZeroMQ операции `zmq_recv` и `zmq_send` могут возвращать ошибки; в production коде нужно проверять коды ошибок и использовать неблокирующие режимы и таймауты.

## Тестирование и запуск

1. Установите зависимости (Ubuntu):
   ```bash
   sudo apt update
   sudo apt install build-essential libzmq3-dev pkg-config
   ```
2. Соберите проект:
   ```bash
   make
   ```
3. Запустите сервер:
   ```bash
   ./server
   ```
4. Запустите клиентов в отдельных терминалах:
   ```bash
   ./client
   ```

## Рекомендации по улучшению

- Переключить обмен сообщениями на структурированный формат (JSON) для устойчивости парсинга.
- Использовать `ROUTER/DEALER` или многопоточную архитектуру внутри сервера для повышения пропускной способности.
- Полная поддержка UTF-8: использовать библиотеку, не зависящую от локали, или хранить и оперировать UTF-8‑строками с явным разбором символов (например, с помощью libunistring или ICU).
- Добавить журналирование и метрики (количество игр, активных подключений, среднее число попыток).

## Заключение

Проект реализует требуемый функционал: две программы (сервер/клиент), работа через очередь сообщений (ZeroMQ), создание и присоединение к играм, многопользовательский режим и сохранение игры при выходе игроков. Основные риски — работа с Unicode (зависимость от локали), текстовый протокол и возможные блокировки при использовании `REQ`/`REP` в условиях высокой нагрузки.

Если нужно, могу добавить диаграмму последовательности, пример JSON‑формата сообщений, или готовый тестовый скрипт автоматизации тестов.
